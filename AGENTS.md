# AGENTS.md

## Описание игр  

Каждая игра представляет из себя сочетание script.lua, config.json, game.json. Игры запускаются на полу из пикселов, каждый размером 30*30см. Так же часть пиксельного поля может находиться на стене(см. NFZ). Левый верхний угол прямоугольного поля представляет из себя 0,0 для pixel_cols и pixel_rows соответственно. Скрипт игры обрабатывается интерпретатором со средним fps в 28.5(может варьироваться в зависимости от типа оборудования в игровой комнате)  

## Назначение репозитория

Репозиторий содержит Lua-скрипты игр Pixel Quest для выполнения в GopherLua (Lua 5.1 + `goto`). Игры 2D, система координат: **(0,0) в левом верхнем углу**, ось X — вправо, ось Y — вниз.

## Обязательные методы скрипта игры

В движке требуется полный набор методов, описанный в `blank_game` (интерпретатор падает, если что-то отсутствует).

<!-- TODO: Сверить точный список обязательных методов в wiki/blank_game и обновить список ниже при необходимости. -->

Базовый список (см. `template_v1/template_v1.lua`):  

- `StartGame(gameJson, gameConfigJson)` — инициализация и старт.
- `NextTick()` — игровой тик; при вовзрате GameResults заканчивает игру
- `RangeFloor(setPixel, setButton)` — снапшот пола/кнопок.
- `GetStats()` — статистика для табло.
- `PauseGame()` / `ResumeGame()` — пауза/возобновление.
- `SwitchStage()` — принудительное переключение этапа.
- `PixelClick(click)` — нажатия на пиксель.
- `ButtonClick(click)` — нажатия на кнопку.
- `DefectPixel(defect)` — дефектовка пикселя.
- `DefectButton(defect)` — дефектовка кнопки.

<!-- TODO: Уточнить сигнатуру и правила использования SendGameResult по wiki/движку. -->

## Полезные материалы в репозитории

- `README.md` — обзор проекта, ссылки на Wiki и список механик.
- `template_v1/template_v1.lua` — эталонный шаблон с комментариями и структурой API.
- `SCOREBOARDS.md` — варианты табло (через `ScoreboardVariant` в статистике). При отсутствии подходящего табло, в папке с игрой создать или модифицировать файл scoreboard.md с описаним небходимого табло
- `AUDIO.md` — загрузка/управление аудиофайлами для наборов звуков.

## Avonlib (avonlib.lua)

Библиотека с утилитами и базовой инфраструктурой игры. Основные элементы:

- Таймеры:
  - `AL.NewTimer(delayMs, callback)` — запланировать таймер.
  - `AL.CountTimers(deltaMs)` — обновлять таймеры каждый тик.
- NFZ (NoFeetZone) — зоны недоступных/статичных пикселей для использования ног. Во всех текущих кейсах - это вертикальная стена из пикселей:
  - `AL.RoomHasNFZ(tGame)` / `AL.LoadNFZInfo()`.
  - `AL.IsPixelInNFZ` / `AL.IsRectInNFZ`.
- Цвета:
  - `AL.LoadColors()` — загрузка палитры из `tGame.Colors` либо дефолтной.

<!-- TODO: Проверить и описать остальные разделы avonlib.lua (Rules/Audio/Video и т.д.) если они используются в новых механиках. -->

## Шаблоны

- `template_v1/template_v1.lua` — минимальный шаблон без avonlib.
- `avon_template/avon_template.lua` — шаблон с `require("avonlib")` и более развитым каркасом (таймеры, NFZ, фазы игры).

## Примечания по данным игры

`game.json` и `config.json` предоставляют поля `Cols`, `Rows`, `Buttons` и другие параметры комнаты/игры. Config.json почти всегда задается челвоеком на стадии запуска игры, в то время как game.json заполняется на этапе разработки игры. Иногда с помощью game.json можно сделать несколько вариаций игры. Кроме того, в game.json можно задавать оверрайды на уровне игровой комнаты по script_id. То есть, у нас есть скрипт игры snake_v1.lua. Есть вариации змейки на 1 и на 5 игроков. При этом у нас игровые комнаты могут быть разного размера. В таком случае для скриптп snake_v1.lua из параметров комнаты пробрасывается оверрайд на game.json. Оверрайд не заменяет полностью этот game.json а только мержит специфичные дял комнаты поля поверх эталонных для данных игр. Для config.json такой механики нет, но существует возможность на уровне пресета игр так же создать оверрайды для мержа(используется для создания пресетов с нестандартной сложностью/сценарными эффектами и т.д.).
